theory "Abstract_btreeLemmas"

imports
    Main "gen_isabelle/Abstract_btree" "~~/src/HOL/Library/Multiset" (* for size_change *)
begin


section "preliminaries"

notation rev_apply (infixl "|>" 100)

(* Quickcheck_Examples/Completeness.thy - should be in Main? simpler defn here*)
definition is_Some :: "'a option => bool" where
  "is_Some x == x ~= None"

lemma [simp]: "(rresult_to_option Error = None) & (rresult_to_option (Ok x) = Some x)"
  apply(force simp add:rev_apply_def rresult_to_option.simps)
  done

lemma FIXME: "P" sorry

section "termination"

termination from_n_to_n' by lexicographic_order

termination page_ref_to_btree by lexicographic_order

termination btree_to_kvs by (force intro:FIXME)  (* the termination of btree_to_kvs is guaranteed only if we have a well-formed btree*)

termination fs_step_as_fun by lexicographic_order

termination insert_step_as_fun by (force intro:FIXME)

section "correctness of fs_step"

lemma from_n_to_n'__eq: "
  from_n_to_n' n n' = [n..<n']"
  apply (induct n')
  apply simp+
done

definition fs_step_invariant :: "('bs,'k,'r,'v) ctxt_t
  => (('r,'bs) store * ('bs,'k,'r,'v) find_state)
  => tree_height
  => 'v value_t option
  => bool" where
  "fs_step_invariant ctxt s0fs0 n0 v0 == (
    let (s0,fs0) = s0fs0 in
    case fs0 of
    Fs_l fsl => (
      let k0 = (fsl|>fsl_k) in
      let r0 = (fsl|>fsl_r) in
      let v' = page_ref_key_to_v ctxt s0 r0 n0 k0 in
      v' = v0)
    | Fs_r fsr => (
      let v' = (fsr|>fsr_v) in
      v' = v0))"

definition wf_ctxts where 
  "wf_ctxts ctxt s0 r0 n0 == (
     case n0 of
      0 \<Rightarrow>
      (case page_ref_to_frame ctxt s0 r0 of
      Some (Frm_L(_)) \<Rightarrow> True
      | _ \<Rightarrow> False)
     | Suc n' \<Rightarrow> (
     case page_ref_to_frame ctxt s0 r0 of
       Some (Frm_I(nf)) \<Rightarrow>
         let n = (nf|>nf_n) in
         let ks = (nf|>nf_ks) in
         let rs = (nf|>nf_rs) :: (nat => 'r page_ref) in
         let k2r :: (('r,'k) node_frame => 'k key => 'r page_ref)= (ctxt |> ctxt_k2r |> dest_k2r) in
          (\<exists> m' \<le> n . ! k .
          let key_p_ref = m'|>rs in
          (* the page_ref returned must be among the inodes page_refs *)
          (k2r nf k) = key_p_ref
          \<and>
          (* the key can be only in the subtree generated by the m' page_ref *)
          (
            (page_ref_key_to_v ctxt s0 r0 (Suc n') k = page_ref_key_to_v ctxt s0 key_p_ref (n') k)
            \<and>
            (! m. m \<le> n \<and> m \<noteq> m' \<longrightarrow> (page_ref_key_to_v ctxt s0 r0 (Suc n') k \<noteq> page_ref_key_to_v ctxt s0 (m|>rs) (n') k))
          )
          ) 
     | _ \<Rightarrow> False))"

definition wf_btree where 
  "wf_btree ctxt s0 r0 n0 == (is_Some (page_ref_to_btree ctxt s0 r0 n0))"

fun wf_store:: "('bs,'k,'r,'v) ctxt_t => ('r,'bs) store => 'r page_ref => tree_height => bool" where
  "wf_store ctxt s0 r0 0 = wf_btree ctxt s0 r0 0"
  | "wf_store ctxt s0 r0 (Suc n') = (
      wf_btree ctxt s0 r0 (Suc n')
      &
      wf_ctxts ctxt s0 r0 (Suc n')

& True)
  "

lemma fs_step_is_invariant: "
  ! (ctxt::('bs,'k,'r,'v) ctxt_t) s0 fs0 n0 v0.
  (case fs0 of Fs_l fsl \<Rightarrow> fsl |> fsl_r | Fs_r fsr \<Rightarrow> fsr |> fsr_r ) = r0
  --> wf_store ctxt s0 r0 n0 
  --> (
  fs_step_invariant ctxt (s0,fs0) n0 v0 --> (
  let x = fs_step ctxt (s0,fs0) in
  case x of 
  None => True  (* if we are at a Fs_r, no further facts are available *)
  | Some (s',fs') => (
    (* n0 could be 0? but then fs' is Fs_r? *)
    fs_step_invariant ctxt (s',fs') (n0 - 1) v0)))"

apply (simp add:Let_def)
apply rule+
apply (case_tac n0)
 (* 0 *)
 apply (simp add:is_Some_def wf_btree_def)
 apply (erule exE)
 apply (rename_tac frm)
 apply (simp add:fs_step_invariant_def)
 apply (case_tac "fs0")
  apply (rename_tac fsl)
  (* fs0 = Fs_l fsl*)
  apply simp
  apply (thin_tac "fs0 = ?x")
  apply (simp add:fs_step_def)
  apply (subgoal_tac "? k0. (fsl |> fsl_k) = k0") prefer 2 apply force
  apply (erule exE)+
  apply (subgoal_tac "? m_frm'. page_ref_to_frame ctxt s0 r0 = m_frm'") prefer 2 apply force
  apply (erule exE)
  apply simp
  apply (case_tac "m_frm'")
   (* m_frm' = None *)
   apply simp
   
   apply (rename_tac frm')
   (* m_frm' = Some frm' *)
   apply simp
   apply (thin_tac "m_frm' = Some frm'")
   apply (case_tac "frm'")
    (* frm' = Frm_I _ *)
    apply (simp add: rev_apply_def rresult_to_option.simps)

    (* frm' = Frm_L _ *)
    apply (simp add:rev_apply_def rresult_to_option_def fs_step_invariant_def page_ref_key_to_v_def 
      page_ref_to_map_def page_ref_to_kvs_def kvs_to_map_def key_to_v_def)

  (* fs0 = Fs_l fsl*)
  apply (simp add:fs_step_def)

 (* n0 = Suc n' *)
 apply (simp add:is_Some_def wf_btree_def)
 apply (erule conjE)+
 apply (erule exE)
 apply (rename_tac "tree")
 apply (subgoal_tac "? m_frm. page_ref_to_frame ctxt s0 (case fs0 of Fs_l fsl \<Rightarrow> fsl |> fsl_r | Fs_r fsr \<Rightarrow> fsr |> fsr_r) = m_frm") prefer 2 apply force
 apply (erule exE)
 apply simp
 apply (case_tac "m_frm")
  (* m_frm = None *)
  apply simp

  apply (rename_tac frm)
  (* m_frm = Some frm *)
  apply simp
  apply (case_tac fs0)
   prefer 2
   (* fs0 = Fs_r find_state_r_ext *)
   apply (simp add:fs_step_def)

   apply (rename_tac fsl)
   (* fs0 = Fs_l fsl*)
   apply (case_tac "frm") 
    prefer 2
    (* frm = Frm_L _*)
    apply simp

    apply (rename_tac nf)
    (* frm = Frm_I nf*)    
    apply (simp add:Let_def wf_ctxts_def from_n_to_n'__eq del:from_n_to_n'.simps)
    apply (erule exE)+
    apply (case_tac "((\<exists>y. page_ref_to_btree ctxt s0 (nf_rs nf (nf_n nf)) nat = Some y) \<and>
             (\<forall>x\<in>{0..<nf_n nf}. \<exists>y. page_ref_to_btree ctxt s0 (nf_rs nf x) nat = Some y) \<and> 0 < nf_n nf)")
     defer
     apply simp

     apply simp
     apply (erule conjE)+
     apply (drule_tac x="fsl|>fsl_k" in spec)
     apply (erule conjE)+
     apply (simp add:fs_step_def)
     apply (simp add:fs_step_invariant_def)
     apply (drule_tac t="v0" in sym)
     apply (simp add: fs_step_invariant_def rev_apply_def)
done

lemma wf_btree_taller_than_1_then_n_keys_ge_1:
" (wf_btree ctxt s0 r0 (Suc n0)) \<longrightarrow> (
 case page_ref_to_frame ctxt s0 r0 of
  Some (Frm_I(nf)) \<Rightarrow>
  let n = (nf|>nf_n) in
  (1 \<le> n)
  | _ \<Rightarrow> False)
"
apply (rule)
apply (simp add:wf_btree_def is_Some_def)
apply (erule exE)
apply (rename_tac tree)
apply (case_tac "page_ref_to_frame ctxt s0 r0")
 (*None*)
 apply simp

 apply (rename_tac "frm")
 (*Some frm*)
 apply (case_tac frm)
  defer
  (* frm = Frm_L lf*)
  apply simp

  apply (rename_tac nf)
  (* frm = Frm_I nf*)
  apply (case_tac "nf |> nf_n = 0")
  defer
   apply simp

   apply (simp add:Let_def rev_apply_def del:from_n_to_n'.simps)
done

section "insert"

lemma insert_step_as_fun_does_not_change_old_tree:
"let (s1,ins1,l1) = insert_step_as_fun ctxt (s0,ins0,l) in
  page_ref_to_map ctxt s1 (ins0 |> ins_r) n0 = page_ref_to_map ctxt s0 (ins0 |> ins_r) n0"
  (* this lemma is proved if insert_step_as_fun_adds_entry_in_new_tree is true *)
oops

lemma insert_step_as_fun_adds_entry_in_new_tree:
"
 let (s1,ins1,l1) = insert_step_as_fun ctxt (s0,ins0,l) in
 (* let us assume that page_ref_to_map succeeds *)
 let m_old_map = page_ref_to_map ctxt s0 (ins0 |> ins_r) n0 in
 let n1 = case (ins1 |> ins_is_taller) of True \<Rightarrow> n0 + 1 | _ \<Rightarrow> n0 in
 let m_new_map = page_ref_to_map ctxt s1 (ins1 |> ins_r) n1 in
 wf_btree ctxt s0 (ins0 |> ins_r) n0 \<and> ((ins0 |> ins_comm) = Insert) \<longrightarrow>
 (case (m_old_map,m_new_map) of
   (Some old_map, Some new_map) \<Rightarrow>
   new_map = (old_map ((fst (ins0 |> ins_kv)) \<mapsto> (snd (ins0 |> ins_kv))))
   | _ \<Rightarrow>
   (* a tree cannot be None if s0 and s1 are well formed *)
   False)"
apply (simp)
apply (subgoal_tac "\<exists> s1 ins1 old_rs1. insert_step_as_fun ctxt (s0, ins0, l) = (s1,ins1,old_rs1)")
 defer apply rule+ apply force apply rule apply force+
apply (erule exE)+
apply simp
apply rule+
apply (subgoal_tac "\<exists> n1. (case ins1 |> ins_is_taller of True \<Rightarrow> n0 + 1 | False \<Rightarrow> n0) = n1")
 defer apply force
apply (erule exE)
apply (case_tac "page_ref_to_map ctxt s0 (ins0 |> ins_r) n0")
 (*None*)
 apply (force intro:FIXME) (*this can be solved easily with wf_btree *)
  
 apply (rename_tac "m0")
 (*Some m0*)
 apply simp
 apply (case_tac "page_ref_to_map ctxt s1 (ins1 |> ins_r) n1")
  (*None*)
  apply (force intro:FIXME) (*this is hard: after showing this, we know that s1 creates a wf_btree *)

  apply (rename_tac "m1")
  (*Some m1*)
  apply (erule conjE)+
  apply (subgoal_tac "ins0 |> ins_comm = ins_comm ins0")
   defer apply (simp add:rev_apply_def)
  apply simp
  apply (thin_tac "ins0 |> ins_comm = Insert")
  apply (simp add:Let_def insert_step_def descending_insert_def)       
  apply (subgoal_tac "\<not>(page_ref_to_frame ctxt s0 (ins_r ins0) = None)")
   defer
   (*this is true by wf_btree*)
   apply (force intro:FIXME)
  apply simp
  apply (erule exE)
  apply simp
  apply (rename_tac "frm")
  apply (case_tac frm)
   apply (rename_tac nf)
   (* frm = Frm_I nf*)
   apply simp
oops
end