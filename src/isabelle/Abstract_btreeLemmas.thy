theory "Abstract_btreeLemmas"

imports
    Main "gen_isabelle/Abstract_btree" "~~/src/HOL/Library/Multiset" (* for size_change *)
begin


section "preliminaries"

notation rev_apply (infixl "|>" 100)

(* Quickcheck_Examples/Completeness.thy - should be in Main? simpler defn here*)
definition is_Some :: "'a option => bool" where
  "is_Some x == x ~= None"

lemma [simp]: "(rresult_to_option Error = None) & (rresult_to_option (Ok x) = Some x)"
  apply(force simp add:rev_apply_def rresult_to_option.simps)
  done

lemma FIXME: "P" sorry

section "termination"

termination page_ref_to_btree by lexicographic_order

termination btree_to_kvs by (force intro:FIXME)  (* the termination of btree_to_kvs is guaranteed only if we have a well-formed btree*)

termination fs_step_as_fun by lexicographic_order

termination insert_step_as_fun by (force intro:FIXME)

section "correctness of fs_step"

definition fs_step_invariant :: "('bs,'k,'r,'v) ctxt_t
  => (('r,'bs) store * ('bs,'k,'r,'v) find_state)
  => tree_height
  => 'v value_t option
  => bool" where
  "fs_step_invariant ctxt s0fs0 n0 v0 == (
    let (s0,fs0) = s0fs0 in
    case fs0 of
    Fs_l fsl => (
      let k0 = (fsl|>fsl_k) in
      let r0 = (fsl|>fsl_r) in
      let v' = page_ref_key_to_v ctxt s0 r0 n0 k0 in
      v' = v0)
    | Fs_r fsr => (
      let v' = (fsr|>fsr_v) in
      v' = v0))"

definition wf_ctxt_k2r where 
  "wf_ctxt_k2r ctxt s0 r0 n0 == (
     case n0 of
      0 \<Rightarrow>
      (case page_ref_to_frame ctxt s0 r0 of
      Some (Frm_L(_)) \<Rightarrow> True
      | _ \<Rightarrow> False)
     | Suc n' \<Rightarrow> (
     case page_ref_to_frame ctxt s0 r0 of
       Some (Frm_I(nf)) \<Rightarrow>
         let n = (nf|>nf_n) in
         let ks = (nf|>nf_ks) in
         let rs = (nf|>nf_rs) :: (nat => 'r page_ref) in
         let k2r :: (('r,'k) node_frame => 'k key => 'r page_ref)= (ctxt |> ctxt_k2r |> dest_k2r) in
          (\<exists> m' \<le> n . ! k .
          let key_p_ref = m'|>rs in
          (* the page_ref returned must be among the inodes page_refs *)
          (k2r nf k) = key_p_ref
          \<and>
          (* the key can be only in the subtree generated by the m' page_ref *)
          (
            (page_ref_key_to_v ctxt s0 r0 (Suc n') k = page_ref_key_to_v ctxt s0 key_p_ref (n') k)
            \<and>
            (! m. m \<le> n \<and> m \<noteq> m' \<longrightarrow> (page_ref_key_to_v ctxt s0 r0 (Suc n') k \<noteq> page_ref_key_to_v ctxt s0 (m|>rs) (n') k))
          )) 
     | _ \<Rightarrow> False))"

definition wf_ctxt_f2p_p2f where
  "wf_ctxt_f2p_p2f ctxt = (
  let f2p = (ctxt |> ctxt_f2p |> dest_f2p) in
  \<forall> r frm s0. 
   let s1 = insert_store s0 (r, (f2p frm)) in
   page_ref_to_frame ctxt s1 r = Some frm
  )"

definition wf_ctxt_free_p_ref where
  "wf_ctxt_free_p_ref ctxt == (
  \<forall> s0.
  let r0 = (s0 |> store_last_free_ref) in
  let s1 = (ctxt |> ctxt_free_p_ref) s0 in
  let r1 = (s1 |> store_last_free_ref) in
  ((s1 |> store_map) = (s0 |> store_map))
  \<and>
  r1 \<notin> (dom (s0 |> store_map))
  \<and>
  r1 \<noteq> r0
  )"

definition wf_ctxt_splitL where
  "wf_ctxt_splitL ctxt == (
  \<forall> kvs. 
  let (kvs1,mk,kvs2) = (ctxt |> ctxt_splitL) kvs in
  mk \<in> dom kvs
  \<and>
  mk \<in> dom kvs2
  \<and>
  kvs = kvs1 ++ kvs2
  \<and>
  (card (dom kvs1)) = ((card (dom kvs)) div 2)
  \<and>
  (card (dom kvs2)) = (card (dom kvs)) - ((card (dom kvs)) div 2)
  )"

definition wf_ctxt_add_k_pr_nf where
  "wf_ctxt_add_k_pr_nf ctxt == (
  let add = (ctxt |> ctxt_add_k_pr_nf) in
  \<forall> m_k r nf. \<exists> r_index.
  let nf' = add m_k r nf in
  let n = (nf' |> nf_n) in
  let ks = (nf' |> nf_ks) in
  let rs = (nf' |> nf_rs) in
  (* add_k_pr_nf does *not* update, it always adds a new pointer *)
  let old_n = (nf |> nf_n) in
  (n = Suc old_n)
  \<and>
  (* the page_ref should be in the node *)
  (rs r_index = r)
  \<and>
  (* and there is not any other index for that page_ref*)
  (\<forall> other_index. (other_index = r_index) = (rs other_index = r))
  \<and>
  (case m_k of
  Some k \<Rightarrow>
    (r_index > 1)
    \<and>
    (ks (r_index - 1) = k)
    \<and>
    (* and there is not any other index for that page_ref*)
    (\<forall> other_index. (other_index = (r_index - 1)) = (ks other_index = k))
  | _ \<Rightarrow> (r_index = 0))
  )"

definition wf_ctxts where 
  "wf_ctxts ctxt s0 r0 n0 == (
  wf_ctxt_k2r ctxt s0 r0 n0
  \<and>
  wf_ctxt_f2p_p2f ctxt
  \<and>
  wf_ctxt_free_p_ref ctxt
  \<and>
  wf_ctxt_splitL ctxt
  )"

definition wf_btree where 
  "wf_btree ctxt s0 r0 n0 == (is_Some (page_ref_to_btree ctxt s0 r0 n0))"

definition wf_store where
  "wf_store ctxt s0 r0 n ==(
      wf_btree ctxt s0 r0 n
      \<and>
      wf_ctxts ctxt s0 r0 n)"

lemma fs_step_is_invariant: "
  ! (ctxt::('bs,'k,'r,'v) ctxt_t) s0 fs0 n0 v0.
  (case fs0 of Fs_l fsl \<Rightarrow> fsl |> fsl_r | Fs_r fsr \<Rightarrow> fsr |> fsr_r ) = r0
  --> wf_store ctxt s0 r0 n0 
  --> (
  fs_step_invariant ctxt (s0,fs0) n0 v0 --> (
  let x = fs_step ctxt (s0,fs0) in
  case x of 
  None => True  (* if we are at a Fs_r, no further facts are available *)
  | Some (s',fs') => (
    (* n0 could be 0? but then fs' is Fs_r? *)
    fs_step_invariant ctxt (s',fs') (n0 - 1) v0)))"

apply (simp add:Let_def)
apply rule+
apply (case_tac n0)
 (* 0 *)
 apply (simp add:is_Some_def wf_store_def wf_btree_def)
 apply (erule conjE)+
 apply (erule exE)+
 apply (rename_tac frm)
 apply (simp add:fs_step_invariant_def)
 apply (case_tac "fs0")
  apply (rename_tac fsl)
  (* fs0 = Fs_l fsl*)
  apply simp
  apply (thin_tac "fs0 = ?x")
  apply (simp add:fs_step_def)
  apply (subgoal_tac "? k0. (fsl |> fsl_k) = k0") prefer 2 apply force
  apply (erule exE)+
  apply (subgoal_tac "? m_frm'. page_ref_to_frame ctxt s0 r0 = m_frm'") prefer 2 apply force
  apply (erule exE)
  apply simp
  apply (case_tac "m_frm'")
   (* m_frm' = None *)
   apply simp
   
   apply (rename_tac frm')
   (* m_frm' = Some frm' *)
   apply simp
   apply (thin_tac "m_frm' = Some frm'")
   apply (case_tac "frm'")
    (* frm' = Frm_I _ *)
    apply (simp add: rev_apply_def rresult_to_option.simps)

    (* frm' = Frm_L _ *)
    apply (simp add:rev_apply_def rresult_to_option_def fs_step_invariant_def page_ref_key_to_v_def 
       page_ref_to_kvs_def key_to_v_def)
    
  (* fs0 = Fs_l fsl*)
  apply (simp add:fs_step_def)

 (* n0 = Suc n' *)
 apply (simp add:is_Some_def wf_store_def wf_btree_def)
 apply (erule conjE)+
 apply (erule exE)
 apply (rename_tac "tree")
 apply (subgoal_tac "? m_frm. page_ref_to_frame ctxt s0 (case fs0 of Fs_l fsl \<Rightarrow> fsl |> fsl_r | Fs_r fsr \<Rightarrow> fsr |> fsr_r) = m_frm") prefer 2 apply force
 apply (erule exE)
 apply simp
 apply (case_tac "m_frm")
  (* m_frm = None *)
  apply simp

  apply (rename_tac frm)
  (* m_frm = Some frm *)
  apply simp
  apply (case_tac fs0)
   prefer 2
   (* fs0 = Fs_r find_state_r_ext *)
   apply (simp add:fs_step_def)

   apply (rename_tac fsl)
   (* fs0 = Fs_l fsl*)
   apply (case_tac "frm") 
    prefer 2
    (* frm = Frm_L _*)
    apply simp

    apply (rename_tac nf)
    (* frm = Frm_I nf*)    
    apply (simp add:Let_def wf_ctxts_def wf_ctxt_k2r_def)
    apply (erule conjE)+
    apply (erule exE)+
    apply (case_tac "((\<exists>y. page_ref_to_btree ctxt s0 (nf_rs nf (nf_n nf)) nat = Some y) \<and>
             (\<forall>x\<in>{0..<nf_n nf}. \<exists>y. page_ref_to_btree ctxt s0 (nf_rs nf x) nat = Some y) \<and> 0 < nf_n nf)")
     defer
     apply simp

     apply simp
     apply (erule conjE)+
     apply (drule_tac x="fsl|>fsl_k" in spec)
     apply (erule conjE)+
     apply (simp add:fs_step_def)
     apply (simp add:fs_step_invariant_def)
     apply (drule_tac t="v0" in sym)
     apply (simp add: fs_step_invariant_def rev_apply_def)
done

lemma wf_btree_taller_than_1_then_n_keys_ge_1:
" (wf_btree ctxt s0 r0 (Suc n0)) \<longrightarrow> (
 case page_ref_to_frame ctxt s0 r0 of
  Some (Frm_I(nf)) \<Rightarrow>
  let n = (nf|>nf_n) in
  (1 \<le> n)
  | _ \<Rightarrow> False)
"
apply (rule)
apply (simp add:wf_btree_def is_Some_def)
apply (erule exE)
apply (rename_tac tree)
apply (case_tac "page_ref_to_frame ctxt s0 r0")
 (*None*)
 apply simp

 apply (rename_tac "frm")
 (*Some frm*)
 apply (case_tac frm)
  defer
  (* frm = Frm_L lf*)
  apply simp

  apply (rename_tac nf)
  (* frm = Frm_I nf*)
  apply (case_tac "nf |> nf_n = 0")
  defer
   apply simp

   apply (simp add:Let_def rev_apply_def)
done

section "insert"

lemma insert_step_as_fun_adds_entry_in_new_tree:
"\<forall> ctxt r ins0 s0 l.
 (wf_store ctxt s0 r n0) \<longrightarrow>
 (let (s1,ins1,l1) = insert_step_as_fun ctxt (s0,ins0,l) in
 (* let us assume that page_ref_to_map succeeds *)
 let m_old_map = page_ref_to_kvs ctxt s0 (ins0 |> ins_r) n0 in
 let n1 = case (ins1 |> ins_is_taller) of True \<Rightarrow> n0 + 1 | _ \<Rightarrow> n0 in
 let m_new_map = page_ref_to_kvs ctxt s1 (ins1 |> ins_r) n1 in
 ((ins0 |> ins_comm) = Insert \<and> ((ins0 |> ins_pi) = [])) \<and>
  (ins0 |> ins_r = r) \<and> (s0 |> store_last_free_ref = (ins0 |> ins_r) ) \<longrightarrow>
 (case (m_old_map,m_new_map) of
   (Some old_map, Some new_map) \<Rightarrow>
   new_map = (old_map ((fst (ins0 |> ins_kv)) \<mapsto> (snd (ins0 |> ins_kv))))
   | _ \<Rightarrow>
   (* a tree cannot be None if s0 and s1 are well formed *)
   False))"
apply (simp)
apply (rule)+
apply simp
apply (thin_tac " b = (aa, ba)")
apply simp
apply (rename_tac s_final ins_final old_rs_final)
apply (subgoal_tac "\<exists> n1. (case ins_final |> ins_is_taller of True \<Rightarrow> n0 + 1 | False \<Rightarrow> n0) = n1")
 defer apply force
apply (erule exE)
apply (erule conjE)
apply (induct n0)
 (* n0 = 0 *)
 apply (simp add:wf_store_def wf_btree_def page_ref_to_kvs_def)
 apply (erule conjE)+
 apply (case_tac "page_ref_to_frame ctxt s0 r")
  (* page_ref_to_frame ctxt s0 (ins0 |> ins_r) = None *)
  apply (simp add:is_Some_def)

  apply (rename_tac "frm")
  apply (simp, case_tac frm)
   (*frm = Frm_I*)
   apply (simp add:is_Some_def)

   apply (rename_tac "lf")
   (*frm = Frm_L lf*)
   apply (simp add:is_Some_def rev_apply_def)+
   (* now we open insert_step *)
   apply (thin_tac "frm=?x")
   apply (simp add:insert_step_def descending_insert_def dup_insert_in_lf_def)
   apply (subgoal_tac "\<exists> frame2page. dest_f2p (ctxt_f2p ctxt) = frame2page") prefer 2 apply force
   apply (erule exE)
   apply simp
   apply (subgoal_tac "\<exists> r0. ins_r ins0 = r0") prefer 2 apply force
   apply (erule exE)
   apply simp
   apply (subgoal_tac "\<exists> s0'. ctxt_free_p_ref ctxt s0 = s0'") prefer 2 apply force
   apply (erule exE)
   apply (subgoal_tac "\<exists> r0'. store_last_free_ref s0' = r0'") prefer 2 apply force
   apply (erule exE)
   apply simp
   apply (subgoal_tac "\<exists> k v. ins_kv ins0 = (k,v) ") prefer 2 apply force
   apply (erule exE)+
   apply simp
   apply (subgoal_tac "\<exists> kvs'. lf_kvs lf(k \<mapsto> v) = kvs' ") prefer 2 apply force
   apply (erule exE)+
   apply simp
   apply (case_tac "card (insert k (dom (lf_kvs lf))) \<le> ctxt_max_fanout ctxt")
    (*size kvs' \<le> ctxt_max_fanout ctxt -- no need to split the leaf: replacement or insertion of a new entry*)
    apply simp
    (* now we unroll insert_step another time and we should get our Ret *)
    apply (simp add:insert_step_def ascending_insert_def dup_ascend_tree_without_splits_def rev_apply_def)
    apply (erule conjE)+
    apply (subgoal_tac "ins_is_taller ins_final = False") prefer 2 apply force
    apply simp
    apply (simp add: page_ref_to_kvs_def)
    apply (subgoal_tac "page_ref_to_frame ctxt s_final (ins_r ins_final) = Some (Frm_L \<lparr>lf_kvs = kvs'\<rparr>)")
    prefer 2
      apply (simp add:wf_ctxts_def)
      apply (erule conjE)+
      apply (simp add:wf_ctxt_f2p_p2f_def)
      apply (drule_tac x="r0'" in spec)
      apply (drule_tac x="(Frm_L \<lparr>lf_kvs = kvs'\<rparr>)" in spec)
      apply (drule_tac x="s0'" in spec)
      apply (simp add:rev_apply_def)
      apply force

    apply (simp add:rev_apply_def)

    (* size kvs' > ctxt_max_fanout ctxt -- we need to split the leaf: we'll have a taller tree! *)
    apply (simp add:wf_ctxts_def)
    apply (erule conjE)+
    (* cleanup of assumptions*)
    apply (thin_tac "ins_comm ins0 = Insert")
    apply (subgoal_tac "
      (( s0' |> store_map) = (s0 |> store_map))
      \<and>
      r0' \<notin> (dom (s0 |> store_map))
      \<and>
      r0' \<noteq> r0") 
    prefer 2 apply (simp add:wf_ctxt_free_p_ref_def) apply (drule_tac x=s0 in spec) apply (simp add:rev_apply_def)
    apply (erule conjE)+
    apply (thin_tac "ctxt_free_p_ref ctxt s0 = s0'")
    apply (case_tac "ctxt_splitL ctxt kvs'")
    apply simp
    apply (rename_tac kvs1 median_k kvs2)
    apply (subgoal_tac "\<exists> s1. ctxt_free_p_ref ctxt s0' = s1") prefer 2 apply force
    apply (erule exE)+
    apply (subgoal_tac "\<exists> q. store_last_free_ref s1 = q") prefer 2 apply force
    apply (erule exE)+
    apply simp
    apply (subgoal_tac "
      ((s1 |> store_map) = (s0' |> store_map)) 
      \<and> 
      (q \<notin> (dom (s0' |> store_map)))
      \<and>
      q \<noteq> r0'") 
    prefer 2 apply (simp add:wf_ctxt_free_p_ref_def) apply (drule_tac x=s0' in spec) apply (simp add:rev_apply_def)
    apply (erule conjE)+
    apply (thin_tac "ctxt_free_p_ref ctxt s0' = s1")
    (* we unroll the insert further, now we are adding the new root*)
    apply (simp add:insert_step_def ascending_insert_def dup_ascend_split_tree_def dup_grow_tree_def)    
    apply (subgoal_tac "\<exists> s2. (insert_store (insert_store s1 (r0', frame2page (Frm_L \<lparr>lf_kvs = kvs1\<rparr>))) (q, frame2page (Frm_L \<lparr>lf_kvs = kvs2\<rparr>))) = s2") prefer 2 apply force
    apply (erule exE)+
    apply simp
    apply (subgoal_tac "\<exists> s3. ctxt_free_p_ref ctxt s2 = s3 ") prefer 2 apply force
    apply (erule exE)+
    apply (subgoal_tac "\<exists> r1'. store_last_free_ref s3 = r1'") prefer 2 apply force
    apply (erule exE)+
    apply simp
    apply (erule conjE)+
    apply (simp add:insert_store_def)
    apply (subgoal_tac "
      ((s3 |> store_map) = (s2 |> store_map)) 
      \<and> 
      (r1' \<notin> (dom (s2 |> store_map)))
      \<and>
      (r1' \<noteq> q)
      ") prefer 2 apply (simp add:wf_ctxt_free_p_ref_def) apply (drule_tac x=s2 in spec) apply (simp add:rev_apply_def) apply force
    apply (erule conjE)+
    apply (thin_tac "ctxt_free_p_ref ctxt s2 = s3")
    apply (thin_tac "ins_pi ins0 = []")
    apply (subgoal_tac "ins_is_taller ins_final") prefer 2 apply force
    apply simp
    apply (thin_tac "ins_is_taller ins_final")
    apply (drule_tac t=n1 in sym)
    apply simp
    apply (thin_tac "n1=?x")
    (* now we can use the wf_ctxts to show that page_ref_to_kvs is not None (wf_ctxt_f2p_p2f), 
    and that kv got inside one of the child nodes (kvs2 by using wf_ctxt_splitL)*)
    apply (subgoal_tac "\<exists> kvs. page_ref_to_kvs ctxt s_final (ins_r ins_final) (Suc 0) = Some kvs") prefer 2 apply (force intro:FIXME)
    apply (erule exE)+
    apply simp
    apply (subgoal_tac "kvs = 
        ((the (page_ref_to_kvs ctxt s_final r0' 0)) ++ (the (page_ref_to_kvs ctxt s_final q 0)))") prefer 2 apply (force intro:FIXME)
    apply simp
    apply (subgoal_tac "the (page_ref_to_kvs ctxt s_final r0' 0) = kvs1")  prefer 2 apply (force intro:FIXME)
    apply (subgoal_tac "the (page_ref_to_kvs ctxt s_final q 0) = kvs2")  prefer 2 apply (force intro:FIXME)
    apply (simp add:wf_ctxt_splitL_def)
    apply (drule_tac x="kvs'" in spec)
    apply (simp add:rev_apply_def)

 (* Suc n0 *)
 apply (subgoal_tac 
   "\<exists> n1' . (case ins_final |> ins_is_taller of True \<Rightarrow> Suc n0 + 1 | False \<Rightarrow> Suc n0)  = Suc n1'")
 prefer 2
  apply (case_tac "ins_final |> ins_is_taller")
   apply (drule_tac t=n1 in sym, simp)+
 apply (thin_tac "(case ins_final |> ins_is_taller of True \<Rightarrow> Suc n0 + 1 | False \<Rightarrow> Suc n0) = n1")
 apply (erule conjE)+
 apply (erule exE)+
 apply simp
 apply (simp add:rev_apply_def insert_step_def descending_insert_def page_ref_to_kvs_def)
 apply (simp add:wf_store_def wf_btree_def)
 apply (erule conjE)
 apply (case_tac "page_ref_to_frame ctxt s0 (ins_r ins0)") 
  (*None*)
  apply (simp add:is_Some_def)
 
  apply (rename_tac frm)
  (*frm*)
 apply (case_tac frm)
  defer
  (*frm = Frm_L *)
  apply (simp add:is_Some_def)

  (*frm = Frm_I*)
  apply (rename_tac nf)
  apply simp
  apply (subgoal_tac "\<exists> n. nf_n nf = n ") prefer 2 apply force
  apply (subgoal_tac "\<exists> rs. nf_rs nf = rs") prefer 2 apply force
  apply (erule exE)+
  apply (simp add:is_Some_def)
  apply (erule exE)
  apply simp
  apply (case_tac "(\<exists>y. page_ref_to_btree ctxt s0 (rs n) n0 = Some y) \<and> (\<forall>x\<in>{0..<n}. \<exists>y. page_ref_to_btree ctxt s0 (rs x) n0 = Some y) \<and> 0 < n")
  apply simp_all
  apply (erule conjE)+
  apply (rename_tac tree)
  apply (simp add:rev_apply_def)
  (* I cannot do anything with the last page_ref_to_kvs, because I have not the *_final:
  so I need to unroll the insert, but the problem is that I will always fall in the Frm_I case of the induction
  *)
  apply (simp add:dup_descend_nf_ref_def)
  apply (case_tac "ins_kv ins0")
  apply simp
  apply (rename_tac k v)
  apply (subgoal_tac "\<exists> s1. ctxt_free_p_ref ctxt s0 = s1") prefer 2 apply force
  apply (erule exE)
  apply (rename_tac tree)
  apply (erule exE)
  apply (simp add:insert_descend del:insert_step_as_fun.simps)
  apply (subgoal_tac "\<exists> r1. s1 |> store_last_free_ref = r1") prefer 2 apply force
  apply (erule exE)
      apply (subgoal_tac "
      (( s1 |> store_map) = (s0 |> store_map))
      \<and>
      r1 \<notin> (dom (s0 |> store_map))
      \<and>
      r1 \<noteq> r") 
    prefer 2 apply (simp add:wf_ctxts_def wf_ctxt_free_p_ref_def) apply (erule conjE)+ apply (drule_tac x=s0 in spec) apply (simp add:rev_apply_def)
  apply (erule conjE)+
  apply (simp add:insert_step_def descending_insert_def)
  apply (simp add:page_ref_to_frame_def ref_to_page_def rev_apply_def)
  
oops

definition insert_invariant where
"insert_invariant ctxt s0ins0l0 n0 =
 (let (s0,ins0,l0) = s0ins0l0 in
 ((wf_store ctxt s0 (ins0 |> ins_r) n0) \<longrightarrow>
 (case (ins0 |> ins_comm) of
  Insert \<Rightarrow>
    \<exists> s1.
    let (k,v) = ins0 |> ins_kv in
    let r0' = s0 |> (ctxt |> ctxt_free_p_ref) |> store_last_free_ref in
    let l1 = l0 (*FIXME this should be a recursive function finding all the refs on the path to kv*) in
    let (s1,ins1,l1) =
     case page_ref_to_frame ctxt s0 (ins0 |> ins_r) of
       Some (Frm_L lf) \<Rightarrow>
       the (dup_insert_in_lf ctxt s0ins0l0 lf)
     | Some (Frm_I nf) \<Rightarrow>
       (case (nf |> nf_n) + 1 = (ctxt |> ctxt_max_fanout) of
       True \<Rightarrow>
        let median_n = (nf |> nf_n) div 2 in
        let ks = (nf |> nf_ks) in
        let mk = ks median_n in
        let q = s1 |> store_last_free_ref in
        (s1,ins0\<lparr> ins_comm := (D(mk,q)), ins_r := r0'\<rparr>,l1)
       | False \<Rightarrow> (s1,ins0\<lparr> ins_comm := S, ins_r := r0'\<rparr>,l1)
       )
     | _ \<Rightarrow> undefined
    in
    (the (page_ref_to_kvs ctxt s0 (ins0 |> ins_r) n0)) (k \<mapsto> v) = (the (page_ref_to_kvs ctxt s1 (ins1 |> ins_r) n0))
    \<and>
    insert_step_as_fun ctxt s0ins0l0 = insert_step_as_fun ctxt (s1,ins1,l1)
  | _ \<Rightarrow> insert_step_as_fun ctxt s0ins0l0 = insert_step_as_fun ctxt s0ins0l0
 )
 ))
"

(*with the following lemma we want only to state that the Insert transition becomes an S or a D,
the other cases are unimportant in this context *)
lemma insert_is_invariant: "
! ctxt s0 fs0 n0 l0 k v pi r.
  let ins0 = \<lparr>ins_comm=Insert, ins_kv=(k,v), ins_r = r, ins_pi = pi, ins_is_taller = False\<rparr> in
  wf_store ctxt s0 r n0
  \<longrightarrow> insert_invariant ctxt (s0,ins0,l0) n0
  \<longrightarrow> (
  let x = insert_step ctxt (s0,ins0,l0) in
  case x of
  None \<Rightarrow> True
  | Some (s1,ins1,l1) \<Rightarrow> (
  insert_invariant ctxt (s1,ins1,l1) (n0 - 1)))
"
apply simp
apply rule+
apply (subgoal_tac "\<exists> ins0. \<lparr>ins_comm = Insert, ins_kv = (k, v), ins_r = r, ins_pi = pi, ins_is_taller = False\<rparr> = ins0 ") prefer 2 apply force
apply (erule exE)
apply simp
apply rule+
apply (case_tac "n0")
 (* n0 = 0 *)
 apply simp

 (* n0 = Suc nat *)
 
oops

(*at this point I must proof that with the insert invariant,
insert actually creates a map with just a kv more than the old map*)
lemma insert_correctness:
"\<forall> ctxt r ins0 s0 l.
 (wf_store ctxt s0 r n0) \<longrightarrow>
 insert_invariant ctxt (s0,ins0,l) n0 \<longrightarrow>
 (let (s1,ins1,l1) = insert_step_as_fun ctxt (s0,ins0,l) in
 (* let us assume that page_ref_to_map succeeds *)
 let m_old_map = page_ref_to_kvs ctxt s0 (ins0 |> ins_r) n0 in
 let n1 = case (ins1 |> ins_is_taller) of True \<Rightarrow> n0 + 1 | _ \<Rightarrow> n0 in
 let m_new_map = page_ref_to_kvs ctxt s1 (ins1 |> ins_r) n1 in
 ((ins0 |> ins_comm) = Insert \<and> ((ins0 |> ins_pi) = [])) \<and>
  (ins0 |> ins_r = r) \<and> (s0 |> store_last_free_ref = (ins0 |> ins_r) ) \<longrightarrow>
 (case (m_old_map,m_new_map) of
   (Some old_map, Some new_map) \<Rightarrow>
   new_map = (old_map ((fst (ins0 |> ins_kv)) \<mapsto> (snd (ins0 |> ins_kv))))
   | _ \<Rightarrow>
   (* a tree cannot be None if s0 and s1 are well formed *)
   False))"
oops
end