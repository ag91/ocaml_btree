open import Pervasives Set_extra Assert_extra

(* Note: this btree data structure requires maxN >= 3*)

module Utility = struct

    (* insertion sort taken from https://ocaml.org/learn/taste.html*)
    let rec s_insert f elem l = (
      match l with
      | [] -> [elem]
      | x :: l ->
         if (f elem x)
         then (elem :: x :: l)
         else (x :: (s_insert f elem l))
      end)

    let rec sort f l = (
      match l with
      | [] -> []
      | x :: l -> s_insert f x (sort f l)
      end)

    (* nth_from_1 xs 1 is the first elt of xs - we count from 1 not 0 *)
    val nth_from_1 : forall 'a.
      list 'a ->
      nat ->
      maybe 'a
    let nth_from_1 xs i = index xs (i-1)

    (* a list containing i..j; hacky *)
    val from_to :
      nat ->
      nat ->
      list nat
    let rec from_to i j = (
      if i=j then [i]
      else
        if i<j
        then i::(from_to (i+1) j)
        else []
    )

    (* find the first index of [l] satisfying a predicate [p] *)
    val first_helper : forall 'a.
       list 'a ->
       ('a -> bool) ->
       nat ->
       nat
    let rec first_helper xs p i = (
      match (nth_from_1 xs i) with
      | Just e -> if p e then i else first_helper xs p (i+1)
      | _ -> i
      end)

    val first : forall 'a.
       list 'a ->
       ('a -> bool) ->
       nat
    let first xs p = (
      first_helper xs p 1
    )

    (* it checks that predicate [p] on the [k]th element of [xs] *)
    val test : forall 'a.
       nat ->
       list 'a ->
       ('a -> bool) ->
       bool
    let test k xs p = (
      match (nth_from_1 xs k) with
      | Just e -> p e
      | _ -> false
      end)

  (* [replace] updates the value of [xs] at
                        index [i] with the new value [a] *)
    val replace_helper: forall 'a.
       ('a * nat * maybe (list 'a) ) ->
       maybe (list 'a)
    let rec replace_helper (a,i,es0) = (
      match es0 with
      | Just es -> (
         match i with
         | 0 -> Nothing
         | 1 -> (
           match es with
           | [] -> Nothing
           | _::xs -> Just (a::xs)
           end)
         | _ -> (
           match es with
           | [] -> Nothing
           | e::es -> (
             match replace_helper(a,i-1,Just es) with
             | Just es -> Just (e::es)
             | _ -> Nothing
             end)
           end)
         end)
      | _ -> Nothing (* coverage:impossible -- replace inputs Just es0 *)
      end)
    val replace : forall 'a.
       ('a * nat * list 'a ) ->
       maybe (list 'a)
    let replace (a,i,es) = replace_helper (a,i,Just es)

    (* [ins] adds a new value [a] at the index [i] of [xs] *)
    val ins_helper : forall 'a.
       ('a * nat * maybe (list 'a) ) ->
       maybe (list 'a)
    let rec ins_helper (a,i,xs0) = (
      match xs0 with
      | Just xs -> (
        match i with
        | 0 -> Nothing
        | 1 -> Just (a::xs)
        | _ -> (
          match xs with
          | [] -> Nothing
          | x::xs -> (
            match (ins_helper (a,i-1, Just xs)) with
            | Just xs' -> Just (x::xs')
            | _ -> Nothing
            end)
          end)
        end)
      | _ -> Nothing (* coverage:impossible -- ins inputs a Just xs0 *)
      end)

    val ins : forall 'a.
       ('a * nat * list 'a ) ->
       maybe (list 'a)
    let ins (a,i,xs) = ins_helper (a,i,Just xs)

    (* [take2] divides the list in two sublists at index [n] *)
    val take2 : forall 'a.
       list 'a ->
       nat ->
       (list 'a * list 'a)
    let rec take2 xs n = (
      match n with
      | 0 -> ([],xs)
      | _ -> (
        match xs with
        | [] -> ([],[])
        | x::xs -> (
            let (b,c) = (take2 xs (n-1)) in
            ((x::b),c))
        end)
      end)

    val del : forall 'a.
       (nat * (list 'a)) ->
       list 'a
    let rec del (i,xs) = (
      match i with
      | 0 -> xs
      | 1 -> (
        match xs with
        | [] -> []
        | _::xs' -> xs'
        end)
      | _ -> (
        match xs with
        | [] -> []
        | x::xs' -> (x::(del ((i-1), xs')))
        end)
      end)
end

module Fs_impl_types = struct
    open Utility

    (*FIXME all these types need to become abstract *)
    (* an abstract of btree content *)
    type entry 'entry = Entry of 'entry
    (* a pointer to a node on disk *)
    type page_id 'p_id = Page_id of 'p_id
    (* the keys of the internal nodes *)
    type key 'k = Key of 'k
    (* the inode contains pointers to nodes on disks divided by keys *)
    type inode 'k 'p = I of (list (key 'k) * list (page_id 'p))
    (* the lnode contains only entries *)
    type lnode 'e = L of (list (entry 'e))
    type node 'p 'e 'k = INode of (inode 'k 'p) | LNode of (lnode 'e)

    (* a store represents the actual content of the disk *)
    type store 'p 'e 'k = map (page_id 'p) (node 'p 'e 'k)

    val nat_empty_btree_store : store nat nat nat
    let nat_empty_btree_store = Map.fromList [(Page_id 0,LNode(L[]))]

    type env 'p 'e 'k =
      <|
        (* fanout of the btree *)
        maxN: nat;
        (* minimum elements in leaves *)
        minN: nat;
        (* entry to key *)
        entry_to_key: entry 'e -> key 'k;
        (* less than on keys *)
        key_lt : key 'k -> key 'k -> bool;
        (* get free page_id in store *)
        free_page_id : store 'p 'e 'k -> page_id 'p
      |>

    val nat_env: env nat nat nat
    let nat_env =
      <|
        maxN = 4;
        minN = 2;
        entry_to_key = (fun (Entry e) -> Key e);
        key_lt = (fun (Key k1) (Key k2) -> k1 < k2);
        free_page_id = (fun store -> match (sort (fun (Page_id x) (Page_id y) -> y < x) (toList (Map.domain store))) with | (Page_id h)::_ -> (Page_id (h+1)) | [] -> (Page_id 0) end);
      |>

    val key_eq : forall 'p 'e 'k.
      env 'p 'e 'k ->
      key 'k ->
      key 'k ->
      bool
    let key_eq env k1 k2 =
      not(env.key_lt k1 k2)
      && not(env.key_lt k2 k1)

    val key_lte : forall 'p 'e 'k.
      env 'p 'e 'k ->
      key 'k ->
      key 'k ->
      bool
    let key_lte env k1 k2 =
      env.key_lt k1 k2 || key_eq env k1 k2

    val entry_lt : forall 'p 'e 'k.
      env 'p 'e 'k ->
      entry 'e ->
      entry 'e ->
      bool
    let entry_lt env e1 e2 =
      env.key_lt (env.entry_to_key e1) (env.entry_to_key e2)

    val entry_eq : forall 'p 'e 'k.
      env 'p 'e 'k ->
      entry 'e ->
      entry 'e ->
      bool
    let entry_eq env e1 e2 =
      (not (env.key_lt (env.entry_to_key e1) (env.entry_to_key e2)))
      &&
        (not (env.key_lt (env.entry_to_key e2) (env.entry_to_key e1)))

    val entry_lte : forall 'p 'e 'k.
      env 'p 'e 'k ->
      entry 'e ->
      entry 'e ->
      bool
    let entry_lte env e1 e2 =
      entry_lt env e1 e2 || entry_eq env e1 e2


    (* insertion types *)
    type ins_comm 'p 'e 'k = Insert of entry 'e | S | D of (key 'k * page_id 'p) | Ret

    type ins_config 'p 'e 'k = ins_comm 'p 'e 'k * page_id 'p * (list (page_id 'p * nat)) * store 'p 'e 'k

    (* find types *)
    type find_comm 'p 'e 'k = Find of key 'k | F_Ret of (page_id 'p * nat)
    type find_config 'p 'e 'k = maybe (find_comm 'p 'e 'k) * page_id 'p * store 'p 'e 'k

    (* delete types *)
    type delete_comm 'p 'e 'k = Delete of entry 'e | DUp | DRem of nat | D_Ret
    type delete_config 'p 'e 'k = delete_comm 'p 'e 'k * page_id 'p * (list (page_id 'p * nat)) * store 'p 'e 'k

end

module BTree = struct
    open Fs_impl_types
    open Utility

    val sorted_entry_list : forall 'p 'e 'k.
      env 'p 'e 'k ->
      list (entry 'e) ->
      bool
    let sorted_entry_list env es =
      if List.length es = 0 then true
      else
        let f1 i =
          let sorted_es = sort (entry_lt env) es in
          let s_e = index sorted_es i in
          let e = index es i in
          (match (s_e,e) with
           | (Just s_e, Just e) -> entry_eq env s_e e
           | _ -> false (* coverage:impossible -- s_e and e lists have the same length, so index op will always find something *)
           end)
        in
        (foldl (fun acc i -> f1 i && acc) true (from_to 0 ((List.length es)-1)))

    val union_list_of_entry_set : forall 'e.
      list (set (entry 'e)) ->
      set (entry 'e)
    let union_list_of_entry_set xs =
      let f1 sofar acc = (union) sofar acc in
      List.foldl f1 empty xs

    (* set of all entries contained in the subtree of the inode
    pointed by [r] in the store [s0] *)
    val entry_set : forall 'p 'e 'k.
      store 'p 'e 'k ->
      page_id 'p ->
      set (entry 'e)
    let rec entry_set s0 r = (
      match Map.lookup r s0 with
      | Nothing -> empty
      | Just node -> (
        match node with
        | LNode(L(es)) -> Set.fromList es
        | INode(I(_,qs)) -> (
          let sets_of_entries = (List.map (entry_set s0) qs) in
          (union_list_of_entry_set sets_of_entries)
        )
        end)
      end)

    (* [get_m] returns the size of the node pointed by [r] in [s0] *)
    val get_m: forall 'p 'k 'e.
      store 'p 'e 'k ->
      page_id 'p ->
      maybe nat
    let get_m s0 r = (
      match Map.lookup r s0 with
      | Nothing -> Nothing
      | Just node -> (
        match node with
        | LNode(L(es))   -> Just (List.length es)
        | INode(I(_,qs)) -> Just (List.length qs)
        end)
      end)


    (* Well formedness *)

    (* [wf_btree] defines the invariants of a btree *)
    val wf_btree : forall 'p 'k 'e.
      env 'p 'e 'k ->
      store 'p 'e 'k ->
      (page_id 'p * set (entry 'e) * nat) ->
      nat ->
      bool
    let rec wf_btree env s0 (r,ss0,n0) h = (match h with
        | 0 -> false
        | 1 -> (
          match Map.lookup r s0 with
          | Nothing -> false
          | Just node -> (
            match node with
            | INode _ -> false
            | LNode (L(es)) -> (
              let n = List.length es in
              match (n = n0) && (n <= env.maxN) with
              | false -> false
              | true -> (
                (* construct a set of entries from es *)
                let ss' = Set.fromList es in
                match setEqual ss0 ss' with
                | false -> false
                | true -> (sorted_entry_list env es)
                end)
              end)
            end)
          end)
        | h_plus_one -> (
          let h = h_plus_one - 1 in
          match Map.lookup r s0 with
          | Nothing -> false
          | Just node -> (
            match node with
            | LNode _ -> false
            | INode(I(ds,qs)) -> (
              match (n0 = List.length qs) && (List.length ds + 1 = List.length qs) with
              | false -> false
              | true -> (
                (* do we know length n0 ~= 0 or 1? n0 cannot be 0, because it is 1 bigger than |ds| *)
                (* "minimum occupancy of each child node to be at
                       least half its maximum capacity (maxN)" - FIXME is
                       this true if n=1? *)
                (* the predicate mentions d1, which means that ds can't be []; this implies that n >= 2 *)
                (* FIXME but for btrees don't we need some
                       properties of the number of keys in each node in
                       relation to maxN? *)
                match ds with
                | [] -> false
                | _::_ -> (
                  let n = n0 in
                  let qq i = nth_from_1 qs i in
                  let ss i = (
                    match qq i with
                    | Just qi -> Just (entry_set s0 qi)
                    | _ -> Nothing
                    end)
                  in
                  let mm i = (
                    match qq i with
                    | Just qi -> get_m s0 qi
                    | _ -> Nothing
                    end)
                  in
                  let dd i = nth_from_1 ds i in
                  let rec_clause =
                    let pred i =
                      let c = (qq i, ss i, mm i) in
                      (match c with
                      | (Just qi, Just si, Just mi) -> (wf_btree env s0 (qi,si,mi) h)
                      | _ -> false
                       end)
                    in
                    List.all pred (from_to 1 n)
                  in
                  let union_clause =
                    let entry_sets = (List.map ss (from_to 1 n)) in
                    if any ((=) Nothing) entry_sets
                    then false
                    else
                      let entry_sets' =
                        foldl (fun acc e -> (match e with | Just e' -> e'::acc | _ -> acc end)) [] entry_sets
                      in
                    (* check S = S_1 Un ... *)
                    let union' = union_list_of_entry_set entry_sets' in
                    setEqual ss0 union'
                  in
                  let cond_sj = (
                    let js = from_to 1 (n-2) in
                    let f3 j =
                      let sj' = ss (j+1) in
                      let dj  = dd j     in
                      let dj' = dd (j+1) in
                      (match (sj',dj,dj') with
                      | (Just sj', Just dj, Just dj') ->
                         Set.all (fun s -> key_lte env dj (env.entry_to_key s)) sj'
                         &&
                           Set.all (fun s -> env.key_lt (env.entry_to_key s) dj') sj'
                      | _ -> false
                       end)
                    in
                    List.all f3 js
                  )
                  in
                  let cond_mj = (
                    let js = from_to 1 n in
                    let pred j =
                      (match mm j with
                      | Nothing -> false
                      | Just mj -> env.minN <= mj
                       end)
                    in
                    List.all pred js
                  )
                  in
                  let cond_s1 = (
                    let d1 = dd 1 in
                    let s1 = ss 1 in
                    (match (d1,s1) with
                     | (Just d1,Just s1) ->
                        Set.all (fun s -> env.key_lt (env.entry_to_key s) d1 ) s1
                     | _ -> false
                     end))
                  in
                  let cond_sn = (
                    let dn' = dd (n-1) in
                    let sn = ss n in
                    (match (dn',sn) with
                     | (Just dn',Just sn) ->
                        Set.all (fun s -> key_lte env dn' (env.entry_to_key s) ) sn
                     | _ -> false
                     end))
                  in
                  rec_clause && union_clause && cond_sj && cond_mj && cond_s1 && cond_sn)
                end)
              end)
            end)
          end)
                                            end)

    (* section 3: insertion as abstract machine rules *)

    (* [split_l] divides a leaf node contents [es] in two leaves
    separated by a key *)
    val split_l : forall 'p 'e 'k.
       env 'p 'e 'k ->
       (nat * entry 'e * list (entry 'e) ) ->
       maybe (list (entry 'e) * key 'k * list (entry 'e) )
    let split_l env (i,a,es0) = (
      match ins (a,i,es0) with
      | Just es ->
         let (es',es'') = take2 es (List.length es / 2 ) in
         (match es'' with
          | [] -> Nothing
          | e::_ ->
             let k = env.entry_to_key e in
             Just (es',k,es'')
          end)
      | _ -> Nothing
      end)

    val split_i : forall 'p 'e 'k.
      (nat * key 'k * page_id 'p * list (key 'k) * list (page_id 'p)) ->
      maybe (list (key 'k) *  list (page_id 'p) * key 'k * list (key 'k) *  list (page_id 'p) )
    let split_i (i,k,q,d,p) = (
      let _ = (List.length p = ((List.length d) + 1)) in
      (match (ins (k,i,d), ins (q,i+1,p)) with
      | (Just ds,Just ps) ->
         let (d',k'::d'') = take2 ds ((List.length ds)/2) in
         let (p',p'') = take2 ps ((List.length d')+1) in
         let _ = (List.length p' = ((List.length d')+1)) in
         let _ = (List.length p'' = ((List.length d'')+1)) in
         let _ = ((List.length p') - (List.length p'') <=1) in
         Just (d',p',k',d'',p'')
      | _ -> Nothing end))

    (* insertion *)
    val insert_trans : forall 'p 'e 'k.
       env 'p 'e 'k ->
       ins_config 'p 'e 'k ->
       maybe (ins_config 'p 'e 'k)
    let insert_trans env c0 = (
      match c0 with
      | (Insert a,r,pi,sg) -> (
        match (Map.lookup r sg) with
        | Just (INode(I(ds,ps))) -> (
          let i = (first ds (fun x -> env.key_lt (env.entry_to_key a) x)) in
          (match nth_from_1 ps i with
           | Nothing -> Nothing
           | Just e -> Just(Insert a,e,(r,i)::pi,sg)
           end))
        | Just (LNode(L(es))) -> (
          let i = first es (fun x -> key_lte env (env.entry_to_key a) (env.entry_to_key x)) in
          if test i es (fun x -> key_eq env (env.entry_to_key a) (env.entry_to_key x)) then
            (match replace(a,i,es) with
             | Just es' ->
                let l' = LNode(L(es')) in
                Just(S,r,pi, Map.insert r l' sg)
             | _ -> Nothing
             end)
          else if List.length es < env.maxN then
            (match ins(a,i,es) with
             | Just es' ->
                let l' = LNode(L(es')) in
                Just(S,r,pi, Map.insert r l' sg)
             | _ -> Nothing
             end)
          else
            (match split_l env (i,a,es) with
             | Just (es',k,es'') ->
               let l1 = LNode(L(es')) in
               let l2 = LNode(L(es'')) in
               let q = env.free_page_id sg in
               let sg' = Map.insert q l2 (Map.insert r l1 sg) in
               Just(D(k,q),r,pi,sg')
             | _ -> Nothing
             end))
        | _ -> Nothing
        end)
      | (S,_,((t,_)::pi),sg) -> Just (S,t,pi,sg) (* if we did not need to split the tree, we just clean the list of added entries *)
      | (D(k,q),_,(t,i)::pi,sg) -> (
        match Map.lookup t sg with
        | Just (INode (I(d,p))) ->
           (match ((List.length p) < env.maxN) with
            | true -> (
              match (ins(k,i,d),ins(q,i+1,p)) with
              | (Just i1, Just i2) ->
                 let i' = INode(I((i1,i2))) in
                 let sg' = Map.insert t i' sg in
                 Just (S,t,pi,sg')
              | _ -> Nothing
              end)
            | false ->
               (match split_i(i,k,q,d,p) with
                | Just (d',p',k',d'',p'') ->
                   let i'  = INode(I(d',p'))   in
                   let i'' = INode(I(d'',p'')) in
                   let q' = env.free_page_id sg in
                   let sg' = Map.insert q' i'' (Map.insert t i' sg) in
                   Just (D(k',q'),t,pi,sg')
                | _ -> Nothing
                end)
            end)
        | _ -> Nothing
        end)
      | (S,r,[],sg) -> Just (Ret,r,[],sg)
      | (D(k,t),r,[],sg) ->
         let q = env.free_page_id sg in
         let i' = (INode(I([k],[r;t]))) in
         let sg' = Map.insert q i' sg in
         Just(Ret,q,[],sg')
      | _ -> Nothing
      end)

    val insert_loop : forall 'p 'e 'k.
       env 'p 'e 'k ->
       ins_config 'p 'e 'k ->
       ins_config 'p 'e 'k
    let rec insert_loop env c0 = (
      match insert_trans env c0 with
      | Nothing -> c0
      | Just c -> insert_loop env c
      end)

    val inserts_in_tree : forall 'p 'e 'k.
       env 'p 'e 'k ->
       (page_id 'p * store 'p 'e 'k) ->
       list (entry 'e) ->
       (page_id 'p * store 'p 'e 'k)
    let inserts_in_tree env (r0,s0) l =
      let dest_root_store (_,r,_,s) = (r,s) in
      List.foldl (fun (r,s) e ->  dest_root_store(insert_loop env (Insert(e),r,[],s))) (r0,s0) l

    (* section 4: find as abstract machine rules *)
    val find_trans : forall 'p 'e 'k.
       env 'p 'e 'k ->
       find_config 'p 'e 'k ->
       find_config 'p 'e 'k
    let find_trans env c0 = (
      match c0 with
      | (Just (Find k),r,sg) -> (
        match Map.lookup r sg with
        | Just (INode(I(ds,ps))) ->
           let i = first ds (fun x -> env.key_lt k x) in
           (match nth_from_1 ps i with
            | Just p -> (Just(Find k),p,sg)
            | _ -> (Nothing,r,sg)
            end)
        | Just (LNode(L(es))) -> (
          let i = (first es (fun x -> key_lte env k (env.entry_to_key x))) in
          (Just (F_Ret(r,i)),r,sg))
        | _ -> (Nothing,r,sg) (* page id does not exist in store *)
        end)
      | _ -> c0 end)

    val find_h : forall 'p 'e 'k.
       env 'p 'e 'k ->
       find_config 'p 'e 'k ->
       nat ->
       (maybe (page_id 'p * nat) * store 'p 'e 'k)
    let rec find_h env c h = (
      match h with
      | 0 -> (
        match c with
        | (Just(F_Ret(p,n)),_,s0) -> (Just(p,n),s0)
        | (_,_,s0) -> (Nothing,s0)
        end)
      | _ -> (
        match c with
        | (Just(F_Ret(p,n)),_,s0) -> (Just(p,n),s0)
        | (_,_,_) ->
           let c' = find_trans env c in
           find_h env c' (h-1)
        end)
      end)

    val find_entry : forall 'p 'e 'k.
       (maybe (page_id 'p * nat) * store 'p 'e 'k) ->
       (maybe (entry 'e))
    let find_entry c = (
      match c with
      | (Just(p,i),s) -> (
         match Map.lookup p s with
         | Just(LNode(L(es))) -> nth_from_1 es i
         | _ -> Nothing
         end)
      | _ -> Nothing
      end)


    val delete_trans : forall 'p 'e 'k.
       env 'p 'e 'k ->
       delete_config 'p 'e 'k ->
       maybe (delete_config 'p 'e 'k)
    let delete_trans env c0 = (
      match c0 with
      | (Delete c, r, pp, sg) -> (
        match (Map.lookup r sg) with
        | Just (INode(I(ds,ps))) -> (* DIDiscend *)
           let i = first ds (fun x -> env.key_lt (env.entry_to_key c) x) in
           (match nth_from_1 ps i with
            | Just pi -> Just (Delete c,pi,((r,i)::pp),sg)
            | _ -> Nothing
            end)
        | Just (LNode(L(es))) ->
           let i = first es (fun x -> key_eq env (env.entry_to_key x) (env.entry_to_key c)) in
           if i = ((List.length es) + 1)
           then (* DLNoMatch *)
             Just(DUp,r,pp,sg)
           else (
             match pp with
             | [] -> (* DLMatchRoot *)
                let l' = LNode(L(del(i,es))) in
                let sg' = Map.insert r l' sg in
                Just(D_Ret,r,pp,sg')
             | (t,j)::pp' ->
                if List.length es > env.minN
                then (* DLMatchOK *)
                  let l' = LNode(L(del(i,es))) in
                  let sg' = Map.insert r l' sg in
                  Just(DUp,t,pp',sg')
                else (
                  match Map.lookup t sg with
                  | Just (INode(I(ds,ps))) -> (
                    match (nth_from_1 ps (j+1)) with (* this condition is equivalent to j!=|p| (error in the paper |p|-1 is the index starting from 0, but first starts from 1), since nth_from_1 is Nothing only if the index is too large *)
                    | Just p_p_1 ->
                       (match Map.lookup p_p_1 sg with
                        | Just (LNode(L(es'))) ->
                           if List.length es' > env.minN
                           then (* DLStealRight *)
                             (match es' with
                              | e0::e1::es'' -> (* here we are implicitly stating that minN >= 2 *)
                                 (match replace((env.entry_to_key e1),j,ds) with
                                  | Just rep_list ->
                                     let sg' =
                                   (Map.insert r (LNode(L(del(i,es)++[e0])))
                                     (Map.insert p_p_1 (LNode(L(del(1,es'))))
                                       (Map.insert t (INode(I(rep_list,ps))) sg)))
                                     in
                                     Just (DUp,t,pp',sg')
                                  | _ -> Nothing
                                 end)
                              | _ -> Nothing
                              end)
                           else (* DLMergeRight*)
                             Nothing
                        | _ -> Nothing (* coverage:impossible -- the node must be a lnode since we are at the bottom of the tree *)
                        end)
                    | Nothing -> (* steal(merge) left only if we cannot steal from the right leaves *)
                       Nothing
                    end)
                  | _ -> Nothing (* coverage:impossible -- cannot be an lnode: the t is added to pp only if the node was an inode *)
                  end)
             end)
        | _ -> Nothing
        end)
      | (DUp,r,pp,sg) -> (
        match pp with
        | (t,_)::pp' -> (* DUp *)
           Just (DUp,t,pp',sg)
        | [] -> (* DRootNoGrow *)
           Just (D_Ret,r,[],sg)
        end)
      | (D_Ret,_,_,_) -> Nothing
      | _ -> Nothing
      end)

    val delete_loop : forall 'p 'e 'k.
       env 'p 'e 'k ->
       delete_config 'p 'e 'k ->
       delete_config 'p 'e 'k
    let rec delete_loop env c0 = (
      match delete_trans env c0 with
      | Nothing -> c0
      | Just c0 -> delete_loop env c0
      end)

    val delete_entries : forall 'p 'e 'k.
       env 'p 'e 'k ->
       (page_id 'p * store 'p 'e 'k) ->
       list (entry 'e) ->
       (page_id 'p * store 'p 'e 'k)
    let delete_entries env (r0,s0) l =
      let dest_root_store (_,r,_,s) = (r,s) in
      List.foldl (fun (r,s) e ->  dest_root_store(delete_loop env (Delete(e),r,[],s))) (r0,s0) l
end
